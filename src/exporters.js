// src/exporters.js
import fs from "node:fs";
import { Buffer } from "node:buffer";
import { PNG } from "pngjs";

export function writeChr(uniqueTiles, bpp) {
  const bytesPerTile = (bpp * 8 * 8) / 8;
  const buf = Buffer.alloc(uniqueTiles.length * bytesPerTile);

  uniqueTiles.forEach((tile, tileIndex) => {
    const { tilePixels } = tile;
    const baseOffset = tileIndex * bytesPerTile;

    let pairIndex = 0;
    for (let plane = 0; plane < bpp; plane += 2) {
      for (let y = 0; y < 8; y++) {
        let byteA = 0;
        let byteB = 0;
        for (let x = 0; x < 8; x++) {
          const idx = tilePixels[y][x] ?? 0;
          const bit = 7 - x;
          if (idx & (1 << plane)) byteA |= 1 << bit;
          if (plane + 1 < bpp && (idx & (1 << (plane + 1)))) byteB |= 1 << bit;
        }
        const offset = baseOffset + pairIndex * 2;
        buf[offset] = byteA;
        buf[offset + 1] = byteB;
        pairIndex++;
      }
    }
  });

  return buf;
}

export function writePal(palette) {
  const entries = palette.entries ?? [];
  const buf = Buffer.alloc(entries.length * 2);

  for (let i = 0; i < entries.length; i++) {
    const c = entries[i];
    if (!c) {
      buf.writeUInt16LE(0x0000, i * 2);
    } else {
      buf.writeUInt16LE(c.snes & 0x7fff, i * 2);
    }
  }

  return buf;
}

export function writeGpl(palette, name = "png2snes") {
  const lines = [];
  lines.push("GIMP Palette");
  lines.push(`Name: ${name}`);
  lines.push("Columns: 16");
  lines.push("# Generated by png2snes");

  const entries = palette.entries ?? [];
  for (let i = 0; i < entries.length; i++) {
    const c = entries[i];
    if (!c) {
      lines.push("  0   0   0");
    } else {
      lines.push(
        `${String(c.r).padStart(3)} ${String(c.g).padStart(3)} ${String(c.b).padStart(3)}`
      );
    }
  }

  return lines.join("\n");
}

/**
 * Gera um PNG (RGBA) com preview do tileset.
 *
 * CORREÇÃO IMPORTANTE (BG 4bpp + palBase + .pal compacta por subpaletas):
 * - O MAP usa paleta FINAL (já inclui palBase), ex.: 2..5
 * - A .pal gerada é "compacta" em número de subpaletas (ex.: 4 subpaletas => 64 cores),
 *   mas cada subpaleta ainda tem 16 entradas (4bpp => 0..15).
 *
 * Também lida com 2 formatos possíveis de tilePixels em 4bpp:
 * A) local 0..15 (CHR) + tile.srcPalette = subpal (0..7)
 * B) absoluto 0..127 onde abs = sub*16 + local (comum em pipeline interno)
 *
 * Regra usada para renderizar:
 *   palFinal = (palBase + sub) & 7
 *   palLocal = palFinal - palBase   (converte para bloco local dentro do .pal compacto)
 *   colorIndex = palLocal*16 + local
 */
export async function writeTilesetPreview({ tiles, palette, outPath, bpp, palBase = 0 }) {
  const columns = 16;
  const rows = Math.ceil(tiles.length / columns);
  const width = columns * 8;
  const height = rows * 8;

  const png = new PNG({ width, height });

  const inferredBpp = Number(bpp);
  if (![4, 8].includes(inferredBpp)) {
    throw new Error(`writeTilesetPreview: bpp inválido: ${bpp} (esperado 4 ou 8)`);
  }

  const palBaseN = Number(palBase);
  if (inferredBpp === 4) {
    if (!Number.isInteger(palBaseN) || palBaseN < 0 || palBaseN > 7) {
      throw new Error(
        `writeTilesetPreview: palBase inválido/ausente: ${palBase} (esperado 0..7)`
      );
    }
  }

  const entries = palette.entries ?? [];
  if (entries.length === 0) {
    throw new Error("writeTilesetPreview: palette.entries vazio");
  }

  // 4bpp: precisa ser múltiplo de 16 (subpaletas compactas em blocos de 16)
  if (inferredBpp === 4 && entries.length % 16 !== 0) {
    throw new Error(
      `writeTilesetPreview: palette.entries (${entries.length}) não é múltiplo de 16 (4bpp exige blocos de 16)`
    );
  }

  const numSubpals = inferredBpp === 4 ? entries.length / 16 : 1;
  if (inferredBpp === 4 && (numSubpals < 1 || numSubpals > 8)) {
    throw new Error(
      `writeTilesetPreview: numSubpals inválido: ${numSubpals} (entries=${entries.length})`
    );
  }

  function writePixel(x, y, colorIndex) {
    const c = entries[colorIndex] || { r: 0, g: 0, b: 0, a: 255 };
    const idx = (width * y + x) << 2;
    png.data[idx] = c.r ?? 0;
    png.data[idx + 1] = c.g ?? 0;
    png.data[idx + 2] = c.b ?? 0;
    png.data[idx + 3] = c.a === 0 ? 0 : 255;
  }

  tiles.forEach((tile, i) => {
    const tx = i % columns;
    const ty = Math.floor(i / columns);

    const srcPal =
      typeof tile?.srcPalette === "number" ? tile.srcPalette : 0;

    for (let y = 0; y < 8; y++) {
      for (let x = 0; x < 8; x++) {
        const mapX = tx * 8 + x;
        const mapY = ty * 8 + y;

        const vRaw = tile?.tilePixels?.[y]?.[x] ?? 0;
        const v = vRaw | 0;

        let colorIndex;

        if (inferredBpp === 8) {
          // 8bpp: índice direto na entries
          colorIndex = v;
          if (!Number.isInteger(colorIndex) || colorIndex < 0 || colorIndex >= entries.length) {
            throw new Error(
              `writeTilesetPreview: colorIndex fora do entries em 8bpp. v=${v}, entries=${entries.length}`
            );
          }
          writePixel(mapX, mapY, colorIndex);
          continue;
        }

        // 4bpp: suportar v local (0..15) ou v absoluto (sub*16+local)
        let local;
        let sub;
        if (v >= 0 && v <= 15) {
          local = v;
          sub = srcPal & 7;
        } else {
          local = v & 0x0f;
          sub = (v >> 4) & 7;
        }

        if (local < 0 || local > 15) {
          throw new Error(
            `writeTilesetPreview: local inválido em 4bpp. v=${v} local=${local}`
          );
        }

        const palFinal = (palBaseN + sub) & 7;
        const palLocal = palFinal - palBaseN;

        if (!Number.isInteger(palLocal) || palLocal < 0 || palLocal >= numSubpals) {
          throw new Error(
            `writeTilesetPreview: palLocal fora do range. ` +
              `v=${v} sub=${sub} local=${local} palBase=${palBaseN} palFinal=${palFinal} palLocal=${palLocal} numSubpals=${numSubpals}`
          );
        }

        colorIndex = palLocal * 16 + local;

        if (colorIndex < 0 || colorIndex >= entries.length) {
          throw new Error(
            `writeTilesetPreview: colorIndex fora do entries em 4bpp. ` +
              `colorIndex=${colorIndex}, entries=${entries.length}, palLocal=${palLocal}, local=${local}`
          );
        }

        writePixel(mapX, mapY, colorIndex);
      }
    }
  });

  const buffer = PNG.sync.write(png);
  await fs.promises.writeFile(outPath, buffer);
}
