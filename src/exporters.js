import fs from "node:fs";
import { Buffer } from "node:buffer";
import { PNG } from "pngjs";

export function writeChr(uniqueTiles, bpp) {
  const bytesPerTile = (bpp * 8 * 8) / 8;
  const buf = Buffer.alloc(uniqueTiles.length * bytesPerTile);

  uniqueTiles.forEach((tile, tileIndex) => {
    const { tilePixels } = tile;
    const baseOffset = tileIndex * bytesPerTile;

    let pairIndex = 0;
    for (let plane = 0; plane < bpp; plane += 2) {
      for (let y = 0; y < 8; y++) {
        let byteA = 0;
        let byteB = 0;
        for (let x = 0; x < 8; x++) {
          const idx = tilePixels[y][x];
          const bit = 7 - x;
          if (idx & (1 << plane)) {
            byteA |= 1 << bit;
          }
          if (plane + 1 < bpp && (idx & (1 << (plane + 1)))) {
            byteB |= 1 << bit;
          }
        }
        const offset = baseOffset + pairIndex * 2;
        buf[offset] = byteA;
        buf[offset + 1] = byteB;
        pairIndex++;
      }
    }
  });

  return buf;
}

export function writePal(palette) {
  const entries = palette.entries || palette;
  const buf = Buffer.alloc(entries.length * 2);
  for (let i = 0; i < entries.length; i++) {
    const v = entries[i].snes;
    buf[i * 2] = v & 0xff;
    buf[i * 2 + 1] = (v >> 8) & 0xff;
  }
  return buf;
}

export function writeGpl(palette, name = "png2snes") {
  const entries = palette.entries || palette;
  let out = "";
  out += "GIMP Palette\n";
  out += `Name: ${name}\n`;
  out += "Columns: 16\n";
  out += "# Generated by png2snes\n";
  for (const c of entries) {
    const r = c.r ?? 0;
    const g = c.g ?? 0;
    const b = c.b ?? 0;
    out += `${r.toString().padStart(3, " ")} ${g
      .toString()
      .padStart(3, " ")} ${b.toString().padStart(3, " ")} \n`;
  }
  return out;
}

export async function writeTilesetPreview({ tiles, palette, outPath }) {
  const columns = 16;
  const rows = Math.ceil(tiles.length / columns);
  const width = columns * 8;
  const height = rows * 8;

  const png = new PNG({ width, height });

  function writePixel(x, y, colorIndex) {
    const c = palette.entries[colorIndex] || {
      r: 0,
      g: 0,
      b: 0,
      a: 255,
    };
    const idx = (width * y + x) << 2;
    png.data[idx] = c.r ?? 0;
    png.data[idx + 1] = c.g ?? 0;
    png.data[idx + 2] = c.b ?? 0;
    png.data[idx + 3] = c.a === 0 ? 0 : 255;
  }

  tiles.forEach((tile, i) => {
    const tx = i % columns;
    const ty = Math.floor(i / columns);
    for (let y = 0; y < 8; y++) {
      for (let x = 0; x < 8; x++) {
        const mapX = tx * 8 + x;
        const mapY = ty * 8 + y;
        writePixel(mapX, mapY, tile.tilePixels[y][x]);
      }
    }
  });

  const buffer = PNG.sync.write(png);
  await fs.promises.writeFile(outPath, buffer);
}

export function writeMetatileJson(outPath, metaJson) {
  fs.writeFileSync(outPath, JSON.stringify(metaJson, null, 2), "utf-8");
}
