import fs from "node:fs";
import { Buffer } from "node:buffer";
import { PNG } from "pngjs";

export function writeChr(uniqueTiles, bpp) {
  const bytesPerTile = (bpp * 8 * 8) / 8;
  const buf = Buffer.alloc(uniqueTiles.length * bytesPerTile);

  uniqueTiles.forEach((tile, tileIndex) => {
    const { tilePixels } = tile;
    const baseOffset = tileIndex * bytesPerTile;

    let pairIndex = 0;
    for (let plane = 0; plane < bpp; plane += 2) {
      for (let y = 0; y < 8; y++) {
        let byteA = 0;
        let byteB = 0;
        for (let x = 0; x < 8; x++) {
          const idx = tilePixels[y][x];
          const bit = 7 - x;
          if (idx & (1 << plane)) {
            byteA |= 1 << bit;
          }
          if (plane + 1 < bpp && (idx & (1 << (plane + 1)))) {
            byteB |= 1 << bit;
          }
        }
        const offset = baseOffset + pairIndex * 2;
        buf[offset] = byteA;
        buf[offset + 1] = byteB;
        pairIndex++;
      }
    }
  });

  return buf;
}

export function writePal(palette) {
  const entries = palette.entries;

  const buf = Buffer.alloc(entries.length * 2);

  for (let i = 0; i < entries.length; i++) {
    const c = entries[i];

    if (!c) {
      // slot vazio = preto/transparente
      buf.writeUInt16LE(0x0000, i * 2);
    } else {
      buf.writeUInt16LE(c.snes & 0x7fff, i * 2);
    }
  }

  return buf;
}

export function writeGpl(palette, name = "png2snes") {
  const lines = [];
  lines.push("GIMP Palette");
  lines.push(`Name: ${name}`);
  lines.push("Columns: 16");
  lines.push("# Generated by png2snes");

  const entries = palette.entries;

  for (let i = 0; i < entries.length; i++) {
    const c = entries[i];
    if (!c) {
      // slot vazio -> preto
      lines.push("  0   0   0");
    } else {
      lines.push(
        `${String(c.r).padStart(3)} ${String(c.g).padStart(3)} ${String(c.b).padStart(3)}`
      );
    }
  }

  return lines.join("\n");
}

export async function writeTilesetPreview({ tiles, palette, outPath }) {
  const columns = 16;
  const rows = Math.ceil(tiles.length / columns);
  const width = columns * 8;
  const height = rows * 8;

  const png = new PNG({ width, height });

  function writePixel(x, y, colorIndex) {
    const c = palette.entries[colorIndex] || {
      r: 0,
      g: 0,
      b: 0,
      a: 255,
    };
    const idx = (width * y + x) << 2;
    png.data[idx] = c.r ?? 0;
    png.data[idx + 1] = c.g ?? 0;
    png.data[idx + 2] = c.b ?? 0;
    png.data[idx + 3] = c.a === 0 ? 0 : 255;
  }

  tiles.forEach((tile, i) => {
    const tx = i % columns;
    const ty = Math.floor(i / columns);
    for (let y = 0; y < 8; y++) {
      for (let x = 0; x < 8; x++) {
        const mapX = tx * 8 + x;
        const mapY = ty * 8 + y;
        writePixel(mapX, mapY, tile.tilePixels[y][x]);
      }
    }
  });

  const buffer = PNG.sync.write(png);
  await fs.promises.writeFile(outPath, buffer);
}

export function writeMetatileJson(outPath, metaJson) {
  fs.writeFileSync(outPath, JSON.stringify(metaJson, null, 2), "utf-8");
}
